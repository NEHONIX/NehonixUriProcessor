/**
 *NOTE: This test has been generated by AI
 */

import { NehonixURIProcessor } from "..";
const checkUrl = NehonixURIProcessor.checkUrl;
// Custom test function
function test(
  name: string,
  callback: () => { actual: any; expected: any },
  debug: boolean = false
): { name: string; passed: boolean; details?: string } {
  try {
    const { actual, expected } = callback();
    let passed = true;
    let details = "";

    // Check isValid
    if (expected.isValid !== undefined && actual.isValid !== expected.isValid) {
      passed = false;
      details += `Expected isValid: ${expected.isValid}, but got: ${actual.isValid}\n`;
    }

    // Check cause
    if (expected.cause !== undefined && actual.cause !== expected.cause) {
      passed = false;
      details += `Expected cause: "${expected.cause}", but got: "${actual.cause}"\n`;
    }

    // Check customValidations
    if (expected.validationDetails?.customValidations) {
      const actualCustom = actual.validationDetails.customValidations;
      if (!actualCustom) {
        passed = false;
        details += "Expected customValidations, but none found\n";
      } else {
        if (
          expected.validationDetails.customValidations.isValid !==
          actualCustom.isValid
        ) {
          passed = false;
          details += `Expected customValidations.isValid: ${expected.validationDetails.customValidations.isValid}, but got: ${actualCustom.isValid}\n`;
        }
        if (expected.validationDetails.customValidations.results) {
          expected.validationDetails.customValidations.results.forEach(
            (expResult, i) => {
              const actResult = actualCustom.results[i];
              if (!actResult || expResult.isValid !== actResult.isValid) {
                passed = false;
                details += `Result[${i}].isValid: Expected ${expResult.isValid}, but got ${actResult?.isValid}\n`;
              }
              if (
                expResult.message &&
                !actResult?.message.includes(expResult.message)
              ) {
                passed = false;
                details += `Result[${i}].message: Expected to include "${expResult.message}", but got "${actResult?.message}"\n`;
              }
            }
          );
        }
      }
    }

    // Check parsing
    if (expected.validationDetails?.parsing) {
      const actualParsing = actual.validationDetails.parsing;
      if (
        !actualParsing ||
        actualParsing.isValid !== expected.validationDetails.parsing.isValid
      ) {
        passed = false;
        details += `Expected parsing.isValid: ${expected.validationDetails.parsing.isValid}, but got: ${actualParsing?.isValid}\n`;
      }
    }

    console.log(`${passed ? "✅" : "❌"} ${name}`);
    if (!passed) {
      console.log(`  Details: ${details}`);
    }
    if (debug || !passed) {
      console.log(`🛠️ Debug Output:\n${JSON.stringify(actual, null, 2)}`);
    }

    return { name, passed, details: passed ? undefined : details };
  } catch (error: any) {
    console.log(`❌ ${name}`);
    console.log(`  Error: ${error.message}`);
    return { name, passed: false, details: error.message };
  }
}

// Test suite
const tests: {
  name: string;
  callback: () => { actual: any; expected: any };
  debug?: boolean;
}[] = [
  {
    name: "Valid URL components",
    callback: () => {
      const url = "https://google.com:8080/api?query=1#section";
      const options = {
        customValidations: [
          ["hostname", "===", "google.com"],
          ["pathname", "===", "/api"],
          ["port", "===", "8080"],
          ["search", "===", "?query=1"],
          ["hash", "===", "#section"],
          ["protocol", "===", "https:"],
          ["host", "===", "google.com:8080"],
        ],
      };
      return {
        actual: checkUrl(url, options as any),
        expected: {
          isValid: true,
          validationDetails: { customValidations: { isValid: true } },
        },
      };
    },
  },
  {
    name: "Literal comparison with literalValue",
    callback: () => {
      const url = "https://google.com";
      const options = {
        customValidations: [
          ["literal", "===", "google.com"],
          ["literal", "!=", "nehonix.space"],
        ],
        literalValue: "google.com",
      };
      return {
        actual: checkUrl(url, options as any),
        expected: {
          isValid: true,
          validationDetails: {
            customValidations: {
              isValid: true,
              results: [
                {
                  isValid: true,
                  message: "Validation passed: literal === google.com",
                },
                {
                  isValid: true,
                  message: "Validation passed: literal != nehonix.space",
                },
              ],
            },
          },
        },
      };
    },
  },
  {
    name: "Missing literalValue",
    callback: () => {
      const url = "https://google.com";
      const options: any = {
        customValidations: [["literal", "===", "google.com"]],
      };
      return {
        actual: checkUrl(url, options),
        expected: {
          isValid: false,
          cause: "One or more custom validations failed",
          validationDetails: {
            customValidations: {
              isValid: false,
              results: [
                {
                  isValid: false,
                  message:
                    "Literal comparison failed: 'literalValue' option is required",
                },
              ],
            },
          },
        },
      };
    },
  },
  {
    name: "Relational operators for hostname",
    callback: () => {
      const url = "https://apple.com";
      const options: any = {
        customValidations: [
          ["hostname", "<=", "banana.com"],
          ["hostname", ">=", "apple.com"],
        ],
      };
      return {
        actual: checkUrl(url, options),
        expected: {
          isValid: true,
          validationDetails: { customValidations: { isValid: true } },
        },
      };
    },
  },
  {
    name: "Relational operators for port",
    callback: () => {
      const url = "https://google.com:8080";
      const options: any = {
        customValidations: [
          ["port", "<=", "8080"],
          ["port", ">=", "8080"],
        ],
      };
      return {
        actual: checkUrl(url, options),
        expected: {
          isValid: true,
          validationDetails: { customValidations: { isValid: true } },
        },
      };
    },
  },
  {
    name: "Invalid component (toJSON)",
    callback: () => {
      const url = "https://google.com";
      const options: any = {
        customValidations: [["toJSON" as any, "==", "nehonix.space"]],
        debug: true,
      };
      return {
        actual: checkUrl(url, options),
        expected: {
          isValid: false,
          cause: "One or more custom validations failed",
          validationDetails: {
            customValidations: {
              isValid: false,
              results: [
                { isValid: false, message: "Invalid URL component 'toJSON'" },
              ],
            },
          },
        },
      };
    },
    debug: true,
  },
  {
    name: "Debug logging for failed validation",
    callback: () => {
      const url = "https://google.com";
      const options: any = {
        customValidations: [["hostname", "===", "example.com"]],
        debug: true,
      };
      return {
        actual: checkUrl(url, options),
        expected: {
          isValid: false,
          validationDetails: {
            customValidations: {
              isValid: false,
              results: [
                {
                  isValid: false,
                  message:
                    "Validation failed: hostname === example.com (actual: google.com)",
                },
              ],
            },
          },
        },
      };
    },
    debug: true,
  },
  {
    name: "Mixed rules (success and failure)",
    callback: () => {
      const url = "https://google.com/api";
      const options: any = {
        customValidations: [
          ["hostname", "===", "google.com"],
          ["pathname", "===", "/wrong"],
          ["literal", "===", "example.com"],
        ],
        literalValue: "google.com",
      };
      return {
        actual: checkUrl(url, options),
        expected: {
          isValid: false,
          validationDetails: {
            customValidations: {
              isValid: false,
              results: [
                {
                  isValid: true,
                  message: "Validation passed: hostname === google.com",
                },
                {
                  isValid: false,
                  message: "Validation failed: pathname === /wrong",
                },
                {
                  isValid: false,
                  message: "Validation failed: literal === example.com",
                },
              ],
            },
          },
        },
      };
    },
  },
  {
    name: "Empty customValidations",
    callback: () => {
      const url = "https://google.com";
      const options: any = { customValidations: [] };
      return {
        actual: checkUrl(url, options),
        expected: { isValid: true },
      };
    },
  },
  {
    name: "Malformed URL",
    callback: () => {
      const url = "not-a-url";
      const options: any = {
        customValidations: [["hostname", "===", "google.com"]],
      };
      return {
        actual: checkUrl(url, options),
        expected: {
          isValid: false,
          validationDetails: { parsing: { isValid: false } },
        },
      };
    },
  },
];

// Run tests
console.log("🚀 Running URL Validation Tests\n");
const results = tests.map((t) => test(t.name, t.callback, t.debug));
const passedCount = results.filter((r) => r.passed).length;
console.log(`\n📊 Test Summary: ${passedCount}/${results.length} passed`);
if (passedCount < results.length) {
  console.log("Failed tests:");
  results.forEach((r) => {
    if (!r.passed) console.log(`  ❌ ${r.name}: ${r.details}`);
  });
}
